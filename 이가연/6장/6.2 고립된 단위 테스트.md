# 6.2 고립된 단위 테스트

![image](https://github.com/user-attachments/assets/3c554136-b5e2-4c38-ab00-72281433b5f2)

비즈니스 로직과 횡단 관심사를 분리함으로서 우리는 고립된 단위 테스트를 손쉽게 만들어낼 수 있다. 

작은 단위 테스트가 좋은 이유는 테스트가 실패했을 때 실행된 로직이 작기 때문에 그 원인을 찾기 쉬워진다는 것이며, 테스트의 의도나 내용이 분명해진다는 장점도 있다. 클래스 하나를 테스트하면서 얼키고 설킨 수많은 의존 관계의 클래스들이 모두 실행되는 것은 비효율적이다. 사실 단순히 클래스만 의존하고 있는 것이 아니다. 결론적으로는 DB 드라이버, DB 서버 자체까지 연결되어있다. 의존 관계는 생각보다 더 거대하다. 

## 6.2.1 복잡한 의존관계 속의 테스트

![image](https://github.com/user-attachments/assets/8de34d10-17af-4dc5-a4ef-a6c68425806c)

따라서 테스트 대상 오브젝트를 다른 모든 영향으로부터 완전히 고립시키기 위해 우리는 Mock 객체를 활용한다. 의존하는 대상을 모두 Mock 객체로 만들어 연쇄적으로 연결된 관계를 모두 끊어버린다. 

단, 이렇게 고립된 이상 DB 연결을 끊어버렸으므로 작업 결과를 직접 검증하기는 어려워졌다. (작업 된 게 애초에 없으니까) 이런 경우 DB 검증 대신 테스트 대상의 메소드가 호출됐는지 검증하는 방식으로 검증이 이루어진다. 이제 우리는 스프링 컨테이너에서 빈을 가져올 필요가 없어졌다. 또 이를 통해 테스트의 시간도 훨씬 빨라졌다. 

## 6.2.3 단위 테스트와 통합 테스트

단위 테스트에 정확한 정의가 있는 건 아니다. 사용자가 정의하기 마련이다. 

다만 단위 테스트는 ‘고립시켜서 검증하고자 하는 기능을 테스트하는 것’, 통합 테스트는 ‘두 개 이상의 오브젝트, 또는 DB 연동 등 서버 자원이 참여하는 테스트’라고 부르자. 

- 항상 단위 테스트를 먼저 고려하라. 단위 테스트는 작성도 간단하고 실행 시간도 빠르다.
- 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다.
- DAO는 서버 자원을 사용하므로 단위 테스트가 아닌 통합 테스트로 만든다.
- 여러 개의 단위가 의존관계를 가지고 동작하면 통합 테스트가 필요하다. 단 단위 테스트가 꼼꼼히 됐다면 통합 테스트의 부담은 상대적으로 줄어든다.
- 단위 테스트로 만들기 너무 복잡하면 통합 테스트로 만들어도 되나, 최대한 많은 단위 테스트를 검증해두는게 유리하다는 것을 기억하라.
- 스프링 테스트 컨텍스트 프레임워크를 사용하는 테스트는 통합 테스트다.

## 6.2.4 Mockito 프레임워크

```java
UserDao mockUserDao = mock(UserDao.class);
```

```java
when(mockUserDao.getAll()).thenReturn(this .users);
```

```java
verify(mockUserDao, times(2)).update(any(User.class));
```

mock(), verify(), when() 등은 모두 Mockito에서 지원하는 메소드다. 

Mockito를 통해 목 객체 생성과 메소드 호출 검증을 쉽게 할 수 있다. 

Mockito를 활용한 단위 테스트 작성 단계는 다음과 같다. 

1. 인터페이스를 이용해 목 오브젝트를 만든다. 
2. 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. ( `when().thenReturn()` ) 
3. 테스트 대상 오브젝트에 목 오브젝트를 DI 해준다. 
4. `verify()` 등을 활용해 메소드 호출 여부나 횟수 등을 검증한다.
