# 6.1 트랜잭션 코드의 분리

비즈니스 로직이 주인이어야 할 메소드 안에 트랜잭션 코드가 더 긴 것이 마음에 들지 않는다. 

트랜잭션 로직과 비즈니스 로직 사이에 주고 받는 정보가 없다는 점에서 분리할 명분이 생긴다. 

## 6.1.2 DI를 이용한 클래스의 분리

DI의 기본적인 아이디어는 실제 사용할 오브젝트 클래스의 정체는 감춘 채 인터페이스를 통해 간접적으로 접근하는 것이다. 

유연한 확장을 위해 인터페이스를 정의하여 UserService와 Client 간의 강한 결합을 끊고 약한 결합으로 만들어준다. 그리고 구현 로직과 트랜잭션 로직을 정의한 클래스가 UserService를 상속하게 만든다. 

![image](https://github.com/user-attachments/assets/21b78f33-1f36-4ae4-9e5b-55c0b478d047)

이를 통해 필요에 따라 구현 로직을 바꿔 가며 사용하면 된다. 또, 의도했던대로 트랜잭션 로직을 밖으로 빼 비즈니스 로직과 분리할 수 있게 되었다. 

- UserServiceImpl : 실제 로직 책임
- UserServiceTx : 트랜잭션 로직 책임

DI를 적용하면 다음과 같은 의존관계가 형성된다. 

![image](https://github.com/user-attachments/assets/49b1dd95-aba0-423f-af42-c2721997691b)

이렇게 비즈니스 로직과 횡단 관심사를 분리하고 DI를 통해 연결하는 장점을 뭐가 있을까?

1. 비즈니스 로직 작성시 횡단 관심사에 대한 부분은 전혀 신경 쓰지 않아도 된다. 그저 UserServiceTx가 먼저 실행되기만 하면 되는 것이다.
2. 분리함으로서 고립된 단위 테스트 작성에 유리해진다.
