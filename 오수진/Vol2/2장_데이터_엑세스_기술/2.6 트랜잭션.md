2.6 트랜잭션 
=
- 트랜잭션 스크립트 : 하나의 트랜잭션 안에서 동작해야 하는 코드를 한 군데 모아서 만드는 방식
- 선언적 트랜잭션을 이용하여 트랜잭션 스크립트를 탈피
- 전파 기능을 사용하면 의미 있는 작은 단위로 만들어진 오브젝트와 메소드를 적절한 순서대로 조합해서 호출하기만 하면 된다. 
- 스프링은 이러한 선언적 트랜잭션 기능을 평범한 POJO 코드에 적용하게 해준다. 

## 2.6.1 트랜잭션 추상화와 동기화

### 트랜잭션 추상화
- 스프링은 다양한 트랜잭션 서비스의 종류와 데이터 액세스 기술 사이의 종속성을 제거
- 트랜잭션 추상 계층을 이용하여 트랜잭션 기능 활용하도록 해줌

### 트랜잭션 동기화
- 트랜잭션을 일정 범위 안에서 유지, 어디서든 자유롭게 접근 가능하도록 해줌
- 선언적 트랜잭션을 가능하게 하는 핵심 기능

### PlatformTransactionManager
- 추상화 핵심 인터페이스
- 모든 스프링 트랜잭션 기능과 코드는 이 인터페이스를 통해 로우레벨의 트랜잭션 서비스를 이용할 수 있다. 
- 트랜잭션 경계를 지정하는 데 사용됨
  - getTransaction(), commit(), rollback()
- TransactionDefinition : 트랜잭션의 네 가지 속성ㅇ

### 트랜잭션 매니저의 종류 : PlatformTransactionManager의 구현 클래스
- DataTransactionManager : Connection의 트랜잭션 API 사용
- JpaTransactionManager
- HibernateTransactionManager
- JmsTransactionManager, CciTransactionManager
- JtaTransactionManager

## 2.6.2 트랜잭션 경계설정 전략
- 경계는 보통 서비스 계층 오브젝트의 메소드
- 방법 1. 코드에 의한 프로그램적인 방법 : 트랜잭션 코드를 직접 만들기
- 방법 2. AOP를 이용한 선언적인 방법 : 기존 코드에 경계설정 기능 부여

### 코드에 의한 트랜잭션 경계설정

### 선언적 트랜잭션 경계설정
- 트랜잭션 프록시 빈 사용
#### AOP와 tx네임스페이스
#### @Transactional
- 트랜잭션이 적용될 타깃 인터페이스나 클래스, 메소드 등에 부여
- 클래스, 인터페이스, 메소드 동시 부여 가능
  - 메소드 > 클래스 > 인터페이스 메소드 > 인터페이스

### 프록시 모드 : 인터페이스와 클래스
- 스프링의 AOP는 기본적으로 다이내믹 프록시 적용
- 다이내믹 프록시는 인터페이스가 필요
- 특별한 경우, 인터페이스를 구현하지 않은 클래스에 트랜잭션 적용하는 경우는??
- 스프링이 지원하는 클래스 프록시 모드 사용!
- GGLib 라이브러리가 제공해주는 클래스 레벨의 프록시
- final에 적용 불가 (클래스 프록시는 타깃 클래스를 상속해서 프록시를 만들기 때문)
- 불필요한 메소드에 트랜잭션 적용되기도 함 (클래스의 모든 메소드에 트랜잭션 적용, 리소스 낭비)

### AOP 방식 : 프록시와 AspectJ
- 스프링의 AOP 는 보통 프록시 방식
- AspectJ는 프록시를 두지 않고, 타깃 오브젝트 자체를 조작해서 부가기능을 직접 넣는 방식
- 다양한 조인 포인트, 고급 기능 사용 가능
- 별도의 빌드 과정이나 바이트코드 조작을 위한 로드타입 위버 설정과 같은 부가 작업이 필요
- 클래스와 클래스 메소드 레벨에 부여해야 함


#### 타깃 오브젝트가 자기 자신의 다른 메소드를 호출할 때
- AopContext.currentProxy()
  - 프록시 설정에서 현재 진행 중인 프록시를 노출하도록 설정
  - 스프링 API가 등장하기 때문에 권장 x
- AspectJ AOP
  - 클래스 바이트 코드 변경

## 2.6.3 트랜잭션 속성
### 1. 트랜잭션 전파 : propagation
- 트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성
#### REQUIRED
- 디폴트
- 있으면 참여, 없으면 생성
#### SUPPORTS
- 있으면 참여, 없으면 없이 진행
#### MANDATORY
- 있으면 참여, 없으면 예외
#### REQUIRES_NEW
- 항상 새로운 트랜잭션
- 이미 진행 중인 것은 보류시킴
#### NOT_SUPPORTED
- 트랜잭션 사용 x
- 이미 진행 중인 것이 있으면 보류
#### NEVER
- 트랜잭션 사용하지 않도록 강제
- 이미 진행 중인 것이 있으면 예외
#### NESTED
- 이미 진행 중인 것이 있으면 중첩 트랜잭션 시작
- 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만 자신의 커밋과 롤백은 부모에게 영향x

### 2. 트랜잭션 격리 수준 : isolation
#### DEFAULT
- 사용하는 데이터 접근 기술이나 DB 드라이버를 따름

#### READ_UNCOMMITED
- 가장 낮은 격리 수준
- 커밋 되기 전의 값을 읽을 수 있음
- 빠름

#### READ_COMMITED
- 가장 많이 사용
- 트랜잭션이 커밋한 결과만 읽을 수 있음
- 같은 로우를 다시 읽을 때 다른 내용을 읽을 수 있음 

#### REPEATABLE_READ
- 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정하는 것을 막는다. 
- 하지만 새로운 로우를 추가하는 것은 제한하지 않음

#### SERIALIZABLE
- 가장 강한 트랜잭션 격리수준
- 여러 트랜잭션이 동시에 같은 테이블 접근 불가
- 성능이 떨어짐

### 3. 트랜잭션 제한시간 : timeout
### 4. 읽기전용 트랜잭션 : read-only, ReadOnly
- 성능 최적화
- 쓰기 작업을 방지
### 5. 트랜잭션 롤백 예외 : rollback-for, rollbackFor, rollbackForClassName
- 런타임 예외 발생 시 롤백
- 예외x or 체크 예외 발생 시 커밋
  - 체크 예외는 비즈니스적 의미를 담은 결과를 돌려주는 용도로 많이 사용되기 때문
- 체크 예외를 롤백하고 싶을 때 사용
### 6. 트랜잭션 커밋 예외 : no-rollback-for, noRollbackFor, noRollbackForClassName
- 런타임 예외를 커밋하고 싶을 때 사용

## 2.6.4 데이터 액세스 기술 트랜잭션의 통합
- 스프링은 DB 당 하나의 트랜잭션 매니저 사용
- DB는 하나인데 두 가지 이상의 데이터 접근 기술을 사용하는 경우는??

### 트랜잭션 매니저별 조합 가능 기술
- 알고 있으면 적절한 기술과 트랜잭션 매니저의 선택이 가능할 것
- DataSourceTransactionManager : JDBC + iBatis
- JpaTransactionManager : JPA + DataSource(JDBC / iBatis)
  - 기본적으로 JPA의 트랜잭션은 JPA API를 이용해 처리되지만 스프링에서는 JPA의 EntityManagerFactoryy가 스프링 빈으로 등록된 DataSource 사용할 수 있고, 이를 JDBC나 iBatis가 사용할 수 있다.
- HibernateTransactionManager : Hibernate + DataSource(JDBC / iBatis)
  - 위와 동일
- JtaTransactionManager : 모든 종류의 데이터 액세스 기술을 같은 트랜잭션 안에서 동작하게 만들 수 있음

### ORM과 비 ORM DAO를 함께 사용할 때의 주의사항
- JPA나 하이버네이트는 단순히 JDBC API를 간접적으로 실행해주는 방식이 아님
- persist()나 save() 메소드 호출 시 바로 INSERT 쿼리 실행되는 것x, 엔티티 매니저나 세션에만 저장해둠
  - 쿼리하는 것을 최대한 지연 (캐싱)
  - 트랜잭션이 끝나기 전에 변경될 수 있기 때문
- 하지만 JDBC는 이를 모름 -> 같은 트랜잭션에서 count()를 실행하면 바로 쿼리를 보내서 조회. 따라서 개수 업데이트 안됨
- 따라서, flush()를 사용해 캐시를 DB에 반영하고 JDBC DAO의 쿼리를 사용해야 함
  - flush()는 캐시의 내용을 즉시 DB에 반영
- AOP를 사용해 JDBC API를 사용하는 곳에 flush() 하는 부가기능을 추가하는 방법도 사용 가능
