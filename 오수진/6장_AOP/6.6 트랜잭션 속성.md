6.6 트랜잭션 속성
-
## 6.6.1 트랜잭션 정의 (TransactionDefinition의 네 가지 속성)
### 1. 트랜잭션 전파
### 2. 격리 수준
### 3. 제한 시간
### 4. 읽기 전용

## 6.6.2 TransactionInterceptor 와 트랜잭션 속성
### TransactionInterceptor
- 스프링이 제공하는 트랜잭션 경계 설정 어드바이스
- 동작방식은 기존에 구현했던 TransactionAdvice 와 같음 + 트랜잭션의 정의를 메소드 이름 패턴으로 지정할 수 있는 방법을 추가로 제공
- PlatformTransactionManager 와 Properties 두 가지 프로퍼티를 가짐
  - PlatformTransactionManager : 트랜잭션 매니저 인터페이스 (추상화)

#### Properties
- TransactionAttributes 의 인터페이스
- 트랜잭션 속성을 정의한 프로퍼티
- TransactionDefinition의 네 가지 속성 + rollbackOn() 메소드
- TransactionAttributes 를 사용하면 트랜잭션 부가기능의 동작 방식을 모두 제어할 수 있다. 

#### rollbackOn() 
- 어떤 예외가 발생하면 롤백을 할 것인가를 결정
- TransactionAdvice 는 RuntimeException 이 발생하는 경우에만 트랜잭션을 롤백시키며 이외의 체크 예외의 경우 예외상황으로 해석하지 않고 트랜잭션을 커밋한다. 
  - 타깃 객체가 런타임 예외가 아니라 체크 예외를 발생시키는 경우, 일종의 비즈니스 로직에 따른 의미가 있는 리턴 방식의 한 가지로 인식하기 때문
  - 스프링의 기본적인 예외 원칙을 따를 것이라 판단
    - *스프링의 예외 원칙*: 비즈니스적 의미가 있는 예외만 체크 예외를 사용, 그 외의 모든 복구 불가능한 순수한 예외의 경우는 모두 런타입 예외로 포장돼서 전달
- 체크 예외에도 트랜잭션을 롤백하고 싶은 예외적 경우에 TransactionAttributes 는 rollbackOn()이라는 속성을 둬서 기본 원칙과 다른 예외처리가 가능하게 해준다.

### 메소드 이름 패턴을 이용한 트랜잭션 속성 지정
- Properties 타입의 transactionAttributes 프로퍼티는 메소드 패턴을 키로, 트랜잭션 속성 문자열을 값으로 갖는 컬렉션이다. 
```
PROPAGATION_NAME, ISOLATION_NAME, readOnly, timeout_NNNN, -Exception1, +Exception2
```
- 순서대로, 트랜잭션 전파 방식, 격리 수준, 읽기 전용 항목, 제한시간, 체크 예외 중 롤백 대상으로 추가할 예외, 런타임 예외지만 롤백시키지 않을 예외
- 생략 가능(생략시 DefaultTransactionDefinition 의 디폴트 속성 부여)

```java
@Configuration
public class SpringConfig {
  @Bean
  public TransactionInterceptor transactionAdvice(PlatformTransactionManager transactionManager) {
    // 메서드 이름에 따라 트랜잭션 속성 매핑
    NameMatchTransactionAttributeSource source = new NameMatchTransactionAttributeSource();

    // read-only transaction 속성 부여
    RuleBasedTransactionAttribute readOnlyAttribute = new RuleBasedTransactionAttribute();
    readOnlyAttribute.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
    readOnlyAttribute.setReadOnly(true);    // 읽기 전용 설정
    readOnlyAttribute.setTimeout(30);       // 제한 시간 설정
    
    // update transaction 속성 부여
    RuleBasedTransactionAttribute updateAttribute = new RuleBasedTransactionAttribute();
    // 항상 독립적인 트랜잭션으로 동작
    updateAttribute.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
    // 완벽하게 고립된 상태에서 트랜잭션이 동작하도록 격리수준을 최고 수준인 ISOLATION_SERIALIZABLE 으로 설정
    updateAttribute.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);
    
    // common transaction 속성 부여 
    RuleBasedTransactionAttribute commonAttribute = new RuleBasedTransactionAttribute();
    commonAttribute.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

    
    Map<String, TransactionAttribute> transactionAttributes = new HashMap<>();

    // read-only transactions 매핑
    transactionAttributes.put("get*", readOnlyAttribute);
    transactionAttributes.put("find*", readOnlyAttribute);
    transactionAttributes.put("select*", readOnlyAttribute);

    // update transaction 매핑
    transactionAttributes.put("update*", updateAttribute);

    // common transactions 매핑 (나머지)
    transactionAttributes.put("*", commonAttribute);

    source.setNameMap(transactionAttributes);

    return new TransactionInterceptor(transactionManager, source);
  }
}
```

## 6.6.3 포인트컷과 트랜잭션 속성의 적용 전략
### 트랜잭션 포인트컷 표현식을 타입 패턴이나 빈 이름을 사용
- 일반적으로 트랜잭션을 적용할 타깃 클래스의 메소드는 모두 트랜잭션 적용 후보가 되는 것이 바람직
  - Service의 add() 다른 트랜잭션에 참여할 가능성이 높기 때문에 트랜잭션 적용하고 전파 방식 속성 부여
  - 단순한 조회 작업도 트랜잭션 적용하고 읽기 전용 속성 & 제한시간 속성 부여해서 성능 높일 수 있다. 
- 따라서, 트랜잭션용 포인트컷 표현식에는 메소드나 파라미터, 예외에 대한 패턴을 정의하지 않고 클래스 단위로 부여하는 것이 바람직하다. 
  - ex) `execution(* *..*ServiceImpl.*(..))`
- 가능하면 클래스보다는 인터페이스 타입을 기준으로 적용하는 것이 좋다. 
  - 인터페이스는 클래스에 비해 변경 빈도가 적고 일정한 패턴을 유지하기 쉽기 때문
- 스프링에서 적용하는 bean() 표현식을 사용해서 빈 이름을 이용할 수 있다.
  - 클래스나 인터페이스 이름에 일정한 규칙을 만들기 어려운 경우에 사용
  - ex) `bean(*Service)`

### 공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다. 
- 실제로 하나의 애플리케이션에서 사용하는 트랜잭션 속성의 종류는 다양하지 않음
  - 다양하면 관리가 힘들기 때문
- 적절한 메소드 명명 규칙을 만들어두고 기준이 되는 트랜잭션 속성을 정의해 매핑하면 하나의 어드바이스로 모든 서비스 빈에 트랜잭션 속성을 지정할 수 있다. 
  - ex) `"get*"`, `"update*"`
- 단, 기본 트랜잭션 속성에서 크게 벗어나는 다른 속성을 가진 타깃 오브젝트가 존재하는 경우, 별도의 어드바이스와 포인트컷 표현식으로 구별하는 것이 관리에 용이하다. 
  - ex) 배치 작업용 클래스

### 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다.  
- 프록시 방식의 AOP에 프록시를 통한 부가기능의 적용은 클라이언트로부터 호출이 일어났을 때만 적용된다. 
- 타깃 오브젝트 내에서 자기 자신의 메소드를 호출할 때에는 프록시가 적용되지 않아 부가기능이 적용되지 않는다.

![image](https://github.com/user-attachments/assets/9fd2348d-87b2-4cbc-8eb6-9d73719621b9)
- 1번과 3번에서는 트랜잭션 부가 기능 적용됨
- 1번 &rarr; 2번의 경우, 1번에서는 트랜잭션 속성이 적용되지만 2번에서는 적용되지 않음

#### 스프링의 트랜잭션 사용 시 주의
- 스프링은 프록시 방식의 AOP를 사용하여 트랜잭션을 관리
- 따라서, 같은 오브젝트 안에서의 호출은 새로운 트랜잭션 속성을 부여하지 못한다는 사실을 의식하고 개발해야 한다.

#### 해결 방법 두 가지
1. 스프링 API 이용해 프록시 오브젝트에 대한 레퍼런스 가져온 뒤에 같은 오브젝트의 호출에도 프록시를 사용하도록 강제하는 방법
   - 스프링 API와 호출코드로 인해 순수한 비즈니스 코드를 해칠 수 있다.
```java
@Service
public class UserServiceImpl implements UserService {
    
    @Autowired
    private ApplicationContext context;
    
    @Transactional
    public void createUserAndNotify(User user) {
        // 사용자 생성 로직
        ...
        
        // 프록시를 통해 메소드 호출
        UserService proxy = context.getBean(UserService.class);
        proxy.sendNotification(user);
    }
    
    @Transactional
    public void sendNotification(User user) {
        // 알림 전송 로직
    }
}
```
2. Aspectj 처럼 프록시 방식이 아니라 타깃의 바이트코드를 직접 조작하는 방식의 AOP 기술을 적용하는 것
   - 기존의 설정 변경 없이 간단한 옵션 변경을 통해 적용할 수 있다.
   - 14장에서 설명할 것
